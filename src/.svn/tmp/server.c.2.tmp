/**
 * @file
 * @brief This file implements the storage server.
 *
 * The storage server should be named "server" and should take a single
 * command line argument that refers to the configuration file.
 *
 * The storage server should be able to communicate with the client
 * library functions declared in storage.h and implemented in storage.c.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <assert.h>
#include <signal.h>
#include "utils.h"
#include <time.h>
#include <stdbool.h>
#include <ctype.h>
#include <math.h>
#include <sys/resource.h>

#define MAX_LISTENQUEUELEN 20   ///< The maximum number of queued connections.
#define storage_PERM 1 // FROM CONFIG FILE => 1 = permanent storage, 0 = memory
#define MAX_NUM_OF_VAL 1 // FROM CONFIG FILE => replace

FILE *fserverOut;

/**
 * @brief Check if key exists in the server
 *
 * @param key_to_search key to search for in server
 * @param keys array holding all the key strings
 * @param first_empty index of the first empty spot in keys & values
 * @return returns true(1) if it exists, false(0) if it doesn't
 */
int key_exist(char key_to_search_for[MAX_KEY_LEN], char tables [MAX_TABLE_LEN][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num)
{
    int i = 0;
    for (i = 0; i < first_empty; i++)
    {
        if (!strcmp(key_to_search_for, tables[table_num][0][i]))
        {
            return 1;
        }
    }
    return 0;
}

/**
 * @brief Remove whitespace from beginning and end of string
 *
 * @param str string to remove leading and trailing whitespace from
 * @return copy of the string
 */
char *trim(char *str)
{
    size_t len = 0;
    char *frontp = str - 1;
    char *endp = NULL;

    if ( str == NULL )
        return NULL;

    if ( str[0] == '\0' )
        return str;

    len = strlen(str);
    endp = str + len;

    /* Move the front and back pointers to address
     * the first non-whitespace characters from
     * each end.
     */
    while ( isspace(*(++frontp)) );
    while ( isspace(*(--endp)) && endp != frontp );

    if ( str + len - 1 != endp )
        *(endp + 1) = '\0';
    else if ( frontp != str &&  endp == frontp )
        *str = '\0';

    /* Shift the string so that it starts at str so
     * that if it's dynamically allocated, we can
     * still free it on the returned pointer.  Note
     * the reuse of endp to mean the front of the
     * string buffer now.
     */
    endp = str;
    if ( frontp != str )
    {
        while ( *frontp ) *endp++ = *frontp++;
        *endp = '\0';
    }


    return str;
}

/**
 * @brief Split a string and return one of the split strings.
 *
 * @param str string to be split
 * @param to_return place to return the specified paramter in str
 * @param param_num which index of the split str to return
 * @param delims string of all characters used to deliminate string
 * @return no return value
 */
void get_param(char str[MAX_VALUE_LEN], char to_return[MAX_VALUE_LEN], int param_num, char *delims)
{
    int i = 0;
    char *pch;
    pch = strtok (str, delims);

    while (pch != NULL)
    {
        if (param_num - i > 0)
        {
            pch = strtok (NULL, delims);
            i++;
        }
        else
        {
            break;
        }
    }
    if (pch == NULL)
    {
        // param doesn't exist, something messed up
        // don't need to catch it here, should be done in parsing
        // of command in client.c or storage.c
    }
    else
    {
        strcpy(to_return, pch);
    }
}

/**
 * @brief Check if table exists in the server
 *
 * @param params config parameters from config file
 * @param table_name table name to search for
 * @return returns true(1) if it exists, false(0) if it doesn't
 */
int has_table(struct config_params params, char table_name[MAX_TABLE_LEN])
{
    int i;
    for (i = 0; i < params.tablecount; i++)
    {
        if (!strcmp(table_name, params.mytables[i]))
        {
            return i;
        }
    }
    return -1;
}

/**
 * @brief Check if table exists in the server
 *
 * @param params config parameters from config file
 * @param table_name table name to search for
 * @return returns column index if it exists, -1 if it doesn't
 */
int has_column(char col_to_search[MAX_COLNAME_LEN], char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], int num_columns, int table_num)
{
    int i;
    for (i = 0; i < num_columns; i++ )
    {
        if (!strcmp(col_to_search, mycolumns[table_num][i]))
        {
            return i;
        }
    }
    return -1;
}

/**
 * @brief Check if the column types match the values given
 *
 * @param val_to_set value to parse
 * @param num_columns number of columns for the table
 * @param table_num index of the table parsing
 * @param column_types types of the columns
 * @return returns true(1) if all column types match, false(0) if it doesn't
 */
int check_column_types(char val_to_set[MAX_VALUE_LEN], int num_columns, int table_num, char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10])
{
    printf("In check_column_types\n");
    int i, len_str;
    char val[MAX_VALUE_LEN], strtoktemp[MAX_VALUE_LEN];

    for (i = 0; i < num_columns; i++)
    {

        strcpy(strtoktemp, val_to_set);
        get_param(strtoktemp, val, i, ",");

        strcpy(strtoktemp, val);
        get_param(strtoktemp, val, 1, " ");
        trim(val);

        len_str = strlen(val);

        printf("atoi value: %d\n", atoi(val));

        if (atoi(val) != 0 && atoi(val) > 0 && len_str != (floor(log10(abs(atoi(val)))) + 1))
        {
            // val is an integer but has alpha characters in it
            printf("fails here\n");
            return -1;
        }
        // Is the value a string
        if (strstr(column_types[table_num][i], "char") != NULL)
        {
            char temp[MAX_VALUE_LEN];
            // Get the max size of the records in the string column
            int start_recording = 0;
            int index = 0, j;
            for (j = 0; column_types[table_num][i][j] != '\0'; j++ )
            {
                if (column_types[table_num][i][j] == '[')
                {
                    start_recording = 1;
                }
                else if (column_types[table_num][i][j] == ']')
                {
                    start_recording = 0;
                }
                else if (start_recording)
                {
                    temp[index] = column_types[table_num][i][j];
                    index++;
                }
            }
            int col_size = atoi(temp);
            if (col_size < len_str)
            {
                printf("fails in here\n");
                return -1;
            }
        }
    }
    return 1;
}

/**
 * @brief Check if the value has the correct matching column names
 *
 * @param val_to_set value to parse
 * @param num_columns number of columns for the table
 * @param table_num index of the table parsing
 * @param mycolumns names of the columns
 * @return returns true(1) if all column names match, false(0) if it doesn't
 */
int check_mycolumns(char val_to_set[MAX_VALUE_LEN], int num_columns, int table_num, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN])
{
    printf("In check_mycolumns\n");
    int i;
    char val[MAX_VALUE_LEN], val_temp[MAX_VALUE_LEN], strtoktemp[MAX_VALUE_LEN];

    for (i = 0; i < num_columns; i++)
    {
        strcpy(strtoktemp, val_to_set);
        get_param(strtoktemp, val_temp, i, ",");

        strcpy(strtoktemp, val_temp);
        get_param(strtoktemp, val, 0, " ");
        if (strcmp(val, mycolumns[table_num][i]))
        {
            return -1;
        }
    }
    return 1;
}

/**
 * @brief Check if the value has the correct number of columns
 *
 * @param val_to_set value to parse
 * @param num_columns number of columns for the table
 * @return returns true(1) if right number of columns, false(0) if it doesn't
 */
int num_col_val(char val_to_set[MAX_VALUE_LEN], int num_columns)
{
    printf("In num_col_val\n");
    printf("num_columns: %d\n", num_columns);
    printf("\told_val\tval\n");
    int i;
    char val[MAX_VALUE_LEN], old_val[MAX_VALUE_LEN], strtoktemp[MAX_VALUE_LEN];
    strcpy(old_val, "");

    for (i = 0; i < num_columns; i++)
    {
        strcpy(strtoktemp, val_to_set);
        get_param(strtoktemp, val, i, ",");
        trim(val);
        printf("\t%s\t%s\n", old_val, val);
        if (!strcmp(val, old_val))
        {
            //too few columns in val_to_set
            return -1;
        }
        strcpy(old_val, val);
    }
    strcpy(strtoktemp, val_to_set);
    get_param(strtoktemp, val, i, ",");
    printf("\t%s\t%s\n", old_val, val);
    if (!strcmp(trim(val), old_val))
    {
        // correct number of columns in val_to_set
        return 1;
    }
    // too many columns in val_to_set
    return -1;
}

/**
 * @brief Checks if the value matches all parsing
 *
 * @param val_to_set value to parse
 * @param table_num table index for the parsing
 * @param params config parameters from config file
 * @return returns true(1) if matches all parsing, false(0) if it doesn't
 */
int parse_value(char val_to_set[MAX_VALUE_LEN], int table_num, struct config_params params)
{
    if (num_col_val(val_to_set, params.numcolumnspertable[table_num]) == -1 || check_mycolumns(val_to_set, params.numcolumnspertable[table_num], table_num, params.mycolumns) == -1 || check_column_types(val_to_set, params.numcolumnspertable[table_num], table_num, params.column_types) == -1)
    {
        return -1;
    }
    return 1;
}

/**
 * @brief Check if all the predicates in the string are formatted correctly
 *
 * @param predicates predicates to parse
 * @param num_columns number of columns for the table
 * @param table_num index of the table parsing
 * @param mycolumns names of the columns
 * @param column_types types of the columns
 * @return returns true(1) if parses correctly, false(0) if it doesn't
 */
int check_predicates(char predicates[MAX_VALUE_LEN], int num_columns, int table_num, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10], int num_pred)
{
    int i;
    char strtoktemp[MAX_VALUE_LEN], pred[MAX_VALUE_LEN], old_pred[MAX_VALUE_LEN], operator[MAX_VALUE_LEN], column_name[MAX_COLNAME_LEN], temp[MAX_COLNAME_LEN];
    printf("Fucks up here\n");
    strcpy(old_pred, "");
    for (i = 0; i < num_pred; i++)
    {
        strcpy(strtoktemp, predicates);
        get_param(strtoktemp, pred, i, ",\0");

        if (!strcmp(pred, old_pred))
        {
            return 1;
        }

        strcpy(strtoktemp, pred);
        get_param(strtoktemp, column_name, 0, " \0");
        get_column_type(column_name, temp, num_columns, table_num, mycolumns, column_types);

        if (!strcmp(temp, "int"))
        {
            strcpy(strtoktemp, pred);
            get_param(strtoktemp, operator, 1, " \0");
            if (strcmp(operator, "=") && strcmp(operator, ">") && strcmp(operator, "<"))
            {
                // Uses an illegal operator
                printf("SKIGGLY\n");
                return -1;
            }
        }
        else
        {
            strcpy(strtoktemp, pred);
            get_param(strtoktemp, operator, 1, " \0");
            if (strcmp(operator, "="))
            {
                printf("SKIGGLY\n");
                // Uses an illegal operator
                return -1;
            }
        }
        strcpy(old_pred, pred);
    }
    return 1;
}

/**
 * @brief Check if the predicate has the correct matching column names
 *
 * @param pred_to_set predicate to parse
 * @param num_columns number of columns for the table
 * @param table_num index of the table parsing
 * @param mycolumns names of the columns
 * @return returns true(1) if all column names match, false(0) if it doesn't
 */
int check_mycolumns_pred(char pred_to_set[MAX_VALUE_LEN], int num_columns, int table_num, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], int num_pred)
{
    printf("In check_mycolumns_pred\n");
    int i, col_index;
    char pred[MAX_VALUE_LEN], pred_temp[MAX_VALUE_LEN], strtoktemp[MAX_VALUE_LEN];
    int column_has_pred[num_columns];

    // Use array to keep track of which columns have a predicate assigned already
    for (i = 0; i < num_columns; i++)
    {
        column_has_pred[i] = 0;
    }

    for (i = 0; i < num_pred; i++)
    {
        strcpy(strtoktemp, pred_to_set);
        get_param(strtoktemp, pred_temp, i, ",\0");

        strcpy(strtoktemp, pred_temp);
        get_param(strtoktemp, pred, 0, " \0");
        printf("%s \\ %s\n", pred, mycolumns[table_num][i]);

        col_index = has_column(pred, mycolumns, num_columns, table_num);

        if (col_index == -1)
        {
            //column name doesn't exist
            return -1;
        }
        if (column_has_pred[col_index] == 1)
        {
            // column name has already been used
            return -1;
        }
        column_has_pred[col_index] = 1;
    }
    return 1;
}

/**
 * @brief Check if the predicate string has the correct number of predicates
 *
 * @param predicates predicates to parse
 * @param num_columns number of columns for the table
 * @return returns true(1) if right number of predicates, false(0) if it doesn't
 */
int num_of_predicates(char predicates[MAX_VALUE_LEN], int num_columns)
{
    printf("In num_of_predicates\n");
    int i;
    char pred[MAX_VALUE_LEN], old_pred[MAX_VALUE_LEN], strtoktemp[MAX_VALUE_LEN];
    strcpy(old_pred, "");

    for (i = 0; i < num_columns; i++)
    {
        strcpy(strtoktemp, predicates);
        get_param(strtoktemp, pred, i, ",\0");

        if (!strcmp(pred, old_pred))
        {
            // num of predicates is less than num_columns
            return i + 1;
        }
        strcpy(old_pred, pred);
    }
    strcpy(strtoktemp, predicates);
    get_param(strtoktemp, pred, i, ",");
    if (!strcmp(pred, old_pred))
    {
        // num of predicates is equal to num_columns
        return num_columns;
    }
    // too many columns in val_to_set
    return -1;
}

/**
 * @brief Umbrella function for all predicate parsing
 *
 * @param predicates predicates to parse
 * @param table_num index of the table parsing
 * @param params config parameters from config file
 * @return returns true(1) if matches all parsing, false(0) if it doesn't
 */
int parse_predicates(char predicates[MAX_VALUE_LEN], int table_num, struct config_params params)
{
    int i = num_of_predicates(predicates, params.numcolumnspertable[table_num]);
    if (i == -1)
    {
        return -1;
    }
    if (check_mycolumns_pred(predicates, params.numcolumnspertable[table_num], table_num, params.mycolumns, i) == -1 || check_predicates(predicates, params.numcolumnspertable[table_num], table_num, params.mycolumns, params.column_types, i) == -1)
    {
        return -1;
    }
    return num_of_predicates(predicates, params.numcolumnspertable[table_num]);
}

/**
 * @brief Get the name of the column based on name given to search for
 *
 * @param column_name column name to find the type for
 * @param num_columns number of columns for the table
 * @param table_num index of the table parsing
 * @param mycolumns names of the columns
 * @param column_types types of the columns
 * @return return string of type of the column
 */
void get_column_type(char column_name[MAX_COLNAME_LEN], char ret_here[MAX_COLNAME_LEN], int num_columns, int table_num, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10])
{
    int i;
    for (i = 1; i < num_columns; i ++)
    {
        if (!strcmp(mycolumns[table_num][i], column_name))
        {
            if (!strcmp(column_types[table_num][i], "int"))
            {
                strcpy(ret_here, "int");
            }
            else
            {
                strcpy(ret_here, "char");
            }
        }
    }
}

/**
 * @brief Convert a row in the data structure to a string with all column names and values
 *
 * @param tables main data strucuture
 * @param row location to return string
 * @param table_num index of the table parsing
 * @param index row index of the entry in the table to get
 * @param num_columns number of columns the table has
 * @param mycolumns names of all the columns of all the tables
 * @return no return value
 */
void get_all_values(char tables [MAX_TABLE_LEN][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], char row[MAX_VALUE_LEN], int table_num, int index, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN])
{
    char value_temp[MAX_VALUE_LEN];
    int i;
    strcpy(value_temp, "");
    for (i = 0; i < num_columns; i++ )
    {
        // Concatenate the column name to the value
        if (i != 0)
        {
            strcat(value_temp, ",");
        }
        strcat(value_temp, mycolumns[table_num][i]);
        strcat(value_temp, " ");
        strcat(value_temp, tables[table_num][i + 1][index]);
    }
    strcpy(row, value_temp);
}

/**
 * @brief Convert a string with all column names and values to a row in the data structure
 *
 * @param tables main data strucuture
 * @param value_to_set string to put into the data structure
 * @param table_num index of the table parsing
 * @param index row index of the entry in the table to get
 * @param num_columns number of columns the table has
 * @return no return value
 */
void set_all_values(char tables [MAX_TABLE_LEN][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], char value_to_set[MAX_VALUE_LEN], int table_num, int index, int num_columns)
{
    char strtoktemp[MAX_STRTYPE_SIZE], value_temp[MAX_VALUE_LEN], key_temp[MAX_KEY_LEN];
    int i;
    for (i = 0; i < num_columns + 1; i++)
    {
        if (i == 0)
        {
            strcpy(strtoktemp, value_to_set);
            get_param(strtoktemp, key_temp, i, ",\0");
            strcpy(strtoktemp, key_temp);
            get_param(strtoktemp, key_temp, 1, " \0");
            strcpy(tables[table_num][i][index], key_temp);
        }
        else
        {
            strcpy(strtoktemp, value_to_set);
            get_param(strtoktemp, value_temp, i, ",\0");
            strcpy(strtoktemp, value_temp);
            get_param(strtoktemp, value_temp, 1, " \0");
            strcpy(tables[table_num][i][index], value_temp);
        }
    }
}

/**
 * @brief Get the specified value based on the key_to_get
 *
 * @param key_to_get key to serach for in keys
 * @param tables main data structure
 * @param first_empty index of the first empty spot in keys & values
 * @param tablenum which table the get is being preformed on
 * @param numcolumns number of columns in the table
 * @return returns the value of the search (ERR_KEY_NOT_FOUND if it DNE)
 */
void get_command(char key_to_get[MAX_KEY_LEN], char value_to_get[MAX_VALUE_LEN], char tables [MAX_TABLE_LEN][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int tablenum, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN])
{
    int index = 0, start = 0, i;
    char val_to_ret[MAX_VALUE_LEN];
    strcpy(val_to_ret, "");

    if (first_empty == 0)
    {
        strcpy(value_to_get, "ERR_KEY_NOT_FOUND");
        return;
    }
    while (index < first_empty)
    {
        if (!strcmp(tables[tablenum][0][index], key_to_get))
        {
            break;
        }
        index++;
    }
    if (index == first_empty && strcmp(tables[tablenum][0][index], key_to_get))
    {
        strcpy(value_to_get, "ERR_KEY_NOT_FOUND");
        return;
    }

    get_all_values(tables, val_to_ret, tablenum, index, num_columns, mycolumns);
    trim(val_to_ret);
    strcpy(value_to_get, val_to_ret);
}

void get_command_perm(char key_to_get[MAX_KEY_LEN], FILE *fileLoadData, char value_to_get[MAX_VALUE_LEN])
{

    char loadLine[MAX_VALUE_LEN];
    char loadLineTemp1[MAX_VALUE_LEN];
    char loadlineTemp2[MAX_VALUE_LEN];
    char *pch = NULL;

    bool stopLoad;
    bool firstPass;
    bool found;
    size_t lengthString;

    firstPass = true;
    stopLoad = false;
    found = false;

    strcpy(loadLine, "");
    strcpy(loadLineTemp1, "");
    strcpy(loadlineTemp2, "");
    strcpy(value_to_get, "");

    do
    {
        strcpy (loadLineTemp1, loadLine);
        fgets(loadLine, MAX_VALUE_LEN, fileLoadData);

        lengthString = strlen(loadLine) - 1;
        if (loadLine[lengthString] == '\n')
            loadLine[lengthString] = '\0';
        strcpy (loadlineTemp2, loadLine);
        pch = strtok (loadlineTemp2, ":");

        if ( (firstPass == false) && (strcmp(loadLineTemp1, loadLine) == 0) )
            stopLoad = true;
        else
        {
            if (strcmp(loadlineTemp2, key_to_get) == 0)
            {
                found = true;
                pch = strtok (NULL, ":");
                strcpy(value_to_get, pch);
            }
        }

        if (firstPass == true)
            firstPass = false;

    }
    while (stopLoad == false);

    if (found == false)
        strcpy(value_to_get, "ERR_KEY_NOT_FOUND");

}

/**
 * @brief Set the item using key_to_set and value_to_set
 *
 * @param key_to_set key to set
 * @param value_to_set value to set
 * @param keys array holding all the key strings
 * @param values array holding all the value strings
 * @param first_empty index of the first empty spot in keys & values
 * @return returns success string if it works (ERR_UNKNOWN if table already at max)
 */
char *set_command(char key_to_set[MAX_KEY_LEN], char value_to_set[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN])
{

    if (first_empty > MAX_RECORDS_PER_TABLE)
    {
        return "ERR_UNKNOWN";
    }
    char row[MAX_VALUE_LEN];
    strcpy(row, "");
    strcat(row, key_to_set);
    strcat(row, ",");
    strcat(row, value_to_set);
    set_all_values(tables, row, table_num, first_empty, num_columns);
    return "SUCCESS";
}

char *set_command_perm(char key_to_set[MAX_KEY_LEN], char value_to_set[MAX_VALUE_LEN], FILE *fileLoadData, FILE *fileWriteData)
{

    // Set, Update, Delete Functionality

    char loadLine[MAX_VALUE_LEN];
    char loadLineTemp1[MAX_VALUE_LEN];
    char loadLineTemp2[MAX_VALUE_LEN];
    char *pch = NULL;

    bool stopLoad;
    bool firstPass;
    bool found;
    bool insert;
    bool deletef;

    size_t lengthString;

    strcpy(loadLine, "");
    strcpy(loadLineTemp1, "");
    strcpy(loadLineTemp2, "");

    firstPass = true;
    stopLoad = false;
    insert = true;
    deletef = false;

if (fileLoadData!=NULL) {

    do
    {
        strcpy (loadLineTemp1, loadLine);
        fgets(loadLine, 100, fileLoadData);

        lengthString = strlen(loadLine) - 1;
        if (loadLine[lengthString] == '\n')
            loadLine[lengthString] = '\0';
        strcpy (loadLineTemp2, loadLine);
        pch = strtok (loadLineTemp2, ":");

        if ( (firstPass == false) && (strcmp(loadLineTemp1, loadLine) == 0) )
            stopLoad = true;
        else
        {
            if (strcmp(loadLineTemp2, key_to_set) == 0)
            {
                insert = false;
                if (deletef == false)
                {
                    fprintf(fileWriteData, "%s:", key_to_set);
                    fprintf(fileWriteData, "%s", value_to_set);
                    fprintf(fileWriteData, "\n");
                }
            }
            else
            {
                if (strcmp(loadLine, "") != 0)
                    fprintf(fileWriteData, "%s\n", loadLine);
            }
        }

        if (firstPass == true)
            firstPass = false;

    }
    while (stopLoad == false);

}

    if (insert == true)
    {
        fprintf(fileWriteData, "%s:", key_to_set);
        fprintf(fileWriteData, "%s", value_to_set);
        fprintf(fileWriteData, "\n");
    }
    return "SUCCESS";
}

/**
 * @brief Set the item using key_to_set and value_to_set
 *
 * @param key_to_update key to set
 * @param value_to_update value to set
 * @param keys array holding all the key strings
 * @param values array holding all the value strings
 * @param first_empty index of the first empty spot in keys & values
 * @return returns success string if it works (always successful, due to key_exist() check)
 */
char *update_command(char key_to_update[MAX_KEY_LEN], char value_to_set[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN])
{

    int index = 0;
    char row[MAX_VALUE_LEN];
    while (index < first_empty)
    {
        if (!strcmp(tables[table_num][0][index], key_to_update))
        {
            strcpy(row, "");
            strcat(row, mycolumns[table_num][0]);
            strcat(row, " ");
            strcat(row, key_to_update);
            strcat(row, ",");
            strcat(row, value_to_set);
            set_all_values(tables, row, table_num, index, num_columns);
            return "SUCCESS";
        }
        index++;
    }
}

/**
 * @brief Get the index of the column based on the column name given
 *
 * @param column_name column name to find the type for
 * @param mycolumns names of the columns
 * @param table_num index of the table parsing
 * @return return the index of the column name given
 */
int get_column_index(char column_name[MAX_COLNAME_LEN], char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], int table_num)
{
    int i;
    for (i = 0; i < MAX_COLUMNS_PER_TABLE; i++)
    {
        if (!strcmp(column_name, mycolumns[table_num][i]))
        {
            return i;
        }
    }
}

/**
 * @brief Check if the value in the row index and column index passes the predicate
 *
 * @param predicate predicate to test for true or false
 * @param tables main data structure
 * @param table_num index of the table parsing
 * @param column_index index of the column to check the predicate for
 * @param row_index index of the row to check the predicate for
 * @param column_types types of the columns
 * @return returns true(1) if the predicate is true, false(0) if it doesn't
 */
int predicate_true(char predicate[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int table_num, int column_index, int row_index, char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10])
{
    char strtoktemp[MAX_VALUE_LEN], operator[MAX_VALUE_LEN], val_to_measure[MAX_VALUE_LEN];
    int int_to_measure, val_in_table;

    if (!strcmp(column_types[table_num][column_index], "int"))
    {
        // column is of type int
        strcpy(strtoktemp, predicate);
        get_param(strtoktemp, operator, 1, " \0");
        strcpy(strtoktemp, predicate);
        get_param(strtoktemp, val_to_measure, 2, " \0");

        trim(operator);
        trim(val_to_measure);
        int_to_measure = atoi(val_to_measure);
        val_in_table = atoi(tables[table_num][column_index][row_index]);
        if (operator[0] == '>')
        {
            if (val_in_table > int_to_measure)
            {
                return 1;
            }
            return -1;
        }
        else if (operator[0] == '<')
        {
            if (val_in_table < int_to_measure)
            {
                return 1;
            }
            return -1;
        }
        else if (operator[0] == '=')
        {
            if (val_in_table == int_to_measure)
            {
                return 1;
            }
            return -1;
        }
    }
    else
    {
        // column is of type int, only operator is '='
        strcpy(strtoktemp, predicate);
        get_param(strtoktemp, val_to_measure, 2, " \0");
        printf("val_to: %s\n",val_to_measure);
        printf("tab: %s\n",tables[table_num][column_index+1][row_index]);
        if (!strcmp(val_to_measure, tables[table_num][column_index+1][row_index]))
        {
            // String equals the predicate value
            return 1;
        }
        // String does not equal the predicate value
        return -1;
    }
}

/**
 * @brief Check if the value in the row index and column index passes the predicates
 *
 * @param predicates predicates to check if true or false
 * @param tables main data structure
 * @param numcolumns number of columns in the table
 * @param table_num index of the table parsing
 * @param mycolumns names of the columns
 * @param column_types types of the columns
 * @param row_index index of the row to check the predicate for
 * @return returns true(1) if the predicate is true, false(0) if it doesn't
 */
int predicates_true(char predicates[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int num_columns, int table_num, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10], int row_index)
{
    char strtoktemp[MAX_VALUE_LEN], pred[MAX_VALUE_LEN], old_pred[MAX_VALUE_LEN], column_name[MAX_COLNAME_LEN];
    int index = 0, col_index;

    strcpy(old_pred, "");
    strcpy(strtoktemp, predicates);
    get_param(strtoktemp, pred, index, ",\0");

    printf("\tpred\t\told_predator\t\tcolumn\n");
    printf("outside\t%s\t%s\t0\n", pred, old_pred);

    while (strcmp(pred, old_pred) != 0)
    {
        strcpy(strtoktemp, pred);
        get_param(strtoktemp, column_name, 0, " \0");

        col_index = get_column_index(column_name, mycolumns, table_num); printf("\t%s\t%s\t%d\n", pred, old_pred, col_index);
        printf("inside\t%s\t%s\t%d\n", pred, old_pred, col_index);
        if (predicate_true(pred, tables, table_num, col_index, row_index, column_types) == -1)
        {
            return -1;
        }
        printf("after\t%s\t%s\t%d\n", pred, old_pred, col_index);
        index++;
        strcpy(old_pred, pred);

        strcpy(strtoktemp, predicates);
        get_param(strtoktemp, pred, index, ",\0");
        printf("end\t%s\t%s\t%d\n", pred, old_pred, col_index);
    }
    return 1;
}

/**
 * @brief Query the table for matching values
 *
 * @param sock The socket connected to the client.
 * @param predicates predicates to check if true or false
 * @param tables main data structure
 * @param first_empty index of the first empty spot in keys & values
 * @param table_num index of the table parsing
 * @param numcolumns number of columns in the table
 * @param mycolumns names of the columns
 * @param column_types types of the columns
 * @return no return value
 */
int query_command(int sock, char predicates[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10])
{
    int matched_lines[MAX_RECORDS_PER_TABLE];
    char comm_string[MAX_CMD_LEN], to_send[MAX_VALUE_LEN];
    int i, index = 0;
    strcpy(comm_string, "");

    for (i = 0; i < first_empty; i++ )
    {
        if (predicates_true(predicates, tables, num_columns, table_num, mycolumns, column_types, i) != -1)
        {
            printf("It matched\n");
            matched_lines[index] = i;
            index++;
        }
    }

    if (index == 0)
    {
        // There are no records in the table that match the predicates
        strcpy(comm_string, "ERR_KEY_NOT_FOUND");
        sendall(sock, comm_string, strlen(comm_string));
        sendall(sock, "\n", 1);
        return -1;
    }

    for (i = 0; i < index; i++)
    {
        strcpy(to_send, tables[table_num][0][matched_lines[i]]);
        sprintf(comm_string, "%d", index - 1 - i);
        strcat(comm_string, ";");
        strcat(comm_string, to_send);
        printf("%s\n",comm_string);
        sendall(sock, comm_string, strlen(comm_string));
        sendall(sock, "\n", 1);

        int wait_for_commands = 1;
        do
        {
            // Read a line from the client.
            char cmd[MAX_CMD_LEN];
            int status = recvline(sock, cmd, MAX_CMD_LEN);
            if (status != 0)
            {
                // Either an error occurred or the client closed the connection.
                wait_for_commands = 0;
            }
            else
            {
                // Handle the command from the client.
                if (strstr(cmd, "SUCCESS"))
                    wait_for_commands = 0; // Got the message, don't need to wait anymore
            }
        }
        while (wait_for_commands);
        printf("End of server comm\n");
    }
    return 0;
}


void query_command_perm(int sock, char predicates[MAX_VALUE_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN], char column_types[MAX_TABLES][MAX_COLUMNS_PER_TABLE][10])
{
    //check if predicate true for THIS line for this table
    //if yes, add num? and value
}




/**
 * @brief Delete the item in the server based on key_to_delete
 *
 * @param key_to_delete key to set
 * @param keys array holding all the key strings
 * @param values array holding all the value strings
 * @param first_empty index of the first empty spot in keys & values
 * @return returns success string if it works (ERR_KEY_NOT_FOUND if key_to_delete DNE in keys)
 */
char *delete_command(char key_to_delete[MAX_KEY_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty, int table_num, int num_columns, char mycolumns[MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_COLNAME_LEN] )
{
    char row[MAX_VALUE_LEN];
    int index = 0, i;
    printf("firstempty: %d\n", first_empty);
    if (first_empty == 0)
    {
        return "ERR_KEY_NOT_FOUND";
    }
    printf("\ttable\tkey_to_delete\n");
    while (index < first_empty)
    {
        printf("\t%s\t%s\n", tables[table_num][0][index], key_to_delete);
        if (!strcmp(tables[table_num][0][index], key_to_delete))
        {
            break;
        }
        index++;
    }
    if (index == first_empty)
    {
        return "ERR_KEY_NOT_FOUND";
    }
    for (; index < first_empty; index++)
    {
        for (i = 0; i < num_columns + 1; i++)
        {
            strcpy(tables[table_num][i][index], tables[table_num][i][index + 1]);
        }
    }
    return "SUCCESS";
}

char *delete_command_perm(char key_to_set[MAX_KEY_LEN], FILE *fileLoadData, FILE *fileWriteData)
{

    // Set, Update, Delete Functionality

    char loadLine[MAX_VALUE_LEN];
    char loadLineTemp1[MAX_VALUE_LEN];
    char loadLineTemp2[MAX_VALUE_LEN];
    char *pch = NULL;

    bool stopLoad;
    bool firstPass;
    bool found;
    bool insert;
    bool deletef;

    size_t lengthString;

    strcpy(loadLine, "");
    strcpy(loadLineTemp1, "");
    strcpy(loadLineTemp2, "");

    firstPass = true;
    stopLoad = false;
    insert = true;
    deletef = true;

    do
    {
        strcpy (loadLineTemp1, loadLine);
        fgets(loadLine, 100, fileLoadData);

        lengthString = strlen(loadLine) - 1;
        if (loadLine[lengthString] == '\n')
            loadLine[lengthString] = '\0';
        strcpy (loadLineTemp2, loadLine);
        pch = strtok (loadLineTemp2, ":");

        if ( (firstPass == false) && (strcmp(loadLineTemp1, loadLine) == 0) )
            stopLoad = true;
        else
        {
            if (strcmp(loadLineTemp2, key_to_set) == 0)
            {
                insert = false;
            }
        }

        if (firstPass == true)
            firstPass = false;

    }
    while (stopLoad == false);

    if (insert == true)
        return "ERR_KEY_NOT_FOUND";

    return "SUCCESS";
}

/**
 * @brief Process a command from the client.
 *
 * @param sock The socket connected to the client.
 * @param params struct that holds all the key config_file information
 * @param cmd The command received from the client.
 * @param keys array holding all the key strings
 * @param values array holding all the value strings
 * @param *first_empty index of the first empty spot in keys & values
 * @param *auth_var variable that keeps track if client is authorized or not
 * @return Returns 0 on success, -1 otherwise.
 */
int handle_command(int sock, struct config_params params, char cmd[MAX_CMD_LEN], char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE], int first_empty[MAX_TABLES], int *auth_var)
{

    char key_temp[MAX_KEY_LEN];
    char value_temp[MAX_VALUE_LEN];
    char strtok_temp[MAX_CMD_LEN];
    char username_temp[MAX_USERNAME_LEN];
    char passwd_temp[MAX_ENC_PASSWORD_LEN];
    char update_value_temp[MAX_VALUE_LEN];
    char table_temp[MAX_TABLE_LEN];
    char pred_temp[MAX_VALUE_LEN];

    char *is_auth = strstr(cmd, "AUTH");
    char *is_get = strstr(cmd, "GET");
    char *is_set = strstr(cmd, "SET");
    char *is_delete = strstr(cmd, "DELETE");
    char *is_query = strstr(cmd, "QUERY");

    int table_index;

    // AUTH comand called
    if (is_auth)
    {
        // Get the username and password from the communication string
        strcpy(strtok_temp, cmd);
        get_param(strtok_temp, username_temp, 1, ";\0");
        strcpy(strtok_temp, cmd);
        get_param(strtok_temp, passwd_temp, 2, ";\0");

        if (!strcmp(params.username, username_temp) && !strcmp(params.password, passwd_temp))
        {
            // Username and password from client cmd are the same as in the config file
            *auth_var = 1;
            strcpy(value_temp, "SUCCESS");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
        }
        else
        {
            // Username and password from client cmd are not the same as in the config file
            strcpy(value_temp, "ERR_AUTHENTICATION_FAILED");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
            return -1;
        }
    }
    else if (is_get)
    {
        if (*auth_var)
        {
            // Get table name from cmd
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, table_temp, 1, ";\0");

            table_index = has_table(params, table_temp);
            if (table_index == -1)
            {
                // table name doesn't exist in the config file / server
                strcpy(value_temp, "ERR_TABLE_NOT_FOUND");
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
                return -1;
            }
            // table exists in config file, continue

            // Get key name from cmd
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, key_temp, 2, ";\0");

            if (storage_PERM == 0)
            {
                // Use memory for server storage
                get_command(key_temp, value_temp, tables, first_empty[table_index], table_index, params.numcolumnspertable[table_index], params.mycolumns);
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
            }
            else
            {
                FILE *fileLoadData;
                char tablenamestring[MAX_TABLE_LEN + 100];
                char datadirectory[MAX_TABLE_LEN + 100];
                strcpy(datadirectory, "data/"); // from config file !!! REPLACE W/ PARSING
                strcpy(tablenamestring, table_temp);
                strcat(tablenamestring, "_tbl.txt");
                strcat(datadirectory, tablenamestring);
                fileLoadData = fopen (datadirectory, "rt");
                get_command_perm(key_temp, fileLoadData, value_temp);
                fclose(fileLoadData);
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
            }
        }
        else
        {
            // Client is not authenticated to the server yet
            strcpy(value_temp, "ERR_NOT_AUTHENTICATED");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
            return -1;
        }
    }
    else if (is_set)
    {
        if (*auth_var)
        {
            // Client is authenticated

            // Get the table name from cmd
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, table_temp, 1, ";\0");

            table_index = has_table(params, table_temp);
            if (table_index == -1)
            {
                // table name DNE in the config params
                strcpy(value_temp, "ERR_TABLE_NOT_FOUND");
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
                return -1;
            }
            // table does exist in config params

            // Get the key and value to store from cmd
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, key_temp, 2, ";\0");
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, value_temp, 3, ";\0");

            if (storage_PERM == 0)
            {
                // Use memory for storing the server
                if (key_exist(key_temp, tables, first_empty[table_index], table_index))
                {
                    // Key exists, do an update
                    trim(value_temp);
                    if (parse_value(value_temp, table_index, params) == 1)
                    {
                        // value string matches the setup of the table
                        strcpy(update_value_temp, update_command(key_temp, value_temp, tables, first_empty[table_index], table_index, params.numcolumnspertable[table_index], params.mycolumns));
                        sendall(sock, update_value_temp, strlen(value_temp));
                        sendall(sock, "\n", 1);
                    }
                    else
                    {
                        // value string does not match the setup of the table
                        strcpy(update_value_temp, "ERR_INVALID_PARAM");
                        sendall(sock, update_value_temp, strlen(update_value_temp));
                        sendall(sock, "\n", 1);
                        return -1;
                    }
                }
                else
                {
                    if (parse_value(value_temp, table_index, params) == 1)
                    {
                        // value string matches the setup of the table
                        strcpy(value_temp, set_command(key_temp, value_temp, tables, first_empty[table_index], table_index, params.numcolumnspertable[table_index], params.mycolumns));
                        sendall(sock, value_temp, strlen(value_temp));
                        sendall(sock, "\n", 1);
                        first_empty[table_index] = first_empty[table_index] + 1;
                    }
                    else
                    {
                        // value string does not match the setup of the table
                        strcpy(update_value_temp, "ERR_INVALID_PARAM");
                        sendall(sock, update_value_temp, strlen(update_value_temp));
                        sendall(sock, "\n", 1);
                        return -1;
                    }
                }
            }
            else
            {
                if (parse_value(value_temp, table_index, params))
                {

                    // check if matches set up
                    FILE *fileLoadData;
                    FILE *fileWriteData;

                    char tablenamestring[MAX_TABLE_LEN + 100];
                    char datadirectory[MAX_TABLE_LEN + 100];

                    char tablenamestringTEMP[MAX_TABLE_LEN + 104];
                    char datadirectoryTEMP[MAX_TABLE_LEN + 104];

                    strcpy(datadirectory, "data/"); // from config file !!! REPLACE W/ PARSING

                    strcpy(tablenamestring, table_temp);
                    strcpy (tablenamestringTEMP, tablenamestring);
                    strcat(tablenamestring, "_tbl.txt");
                    strcat(tablenamestringTEMP, "_tbl_TEMP.txt");
                    strcat(datadirectory, tablenamestring);
                    strcat(datadirectoryTEMP, tablenamestringTEMP);
                    fileLoadData = fopen (datadirectory, "rt");
                    fileWriteData = fopen (datadirectoryTEMP, "w");
                    strcpy(update_value_temp, set_command_perm(key_temp, value_temp, fileLoadData, fileWriteData));
                    if (fileLoadData!=NULL)
		    	fclose(fileLoadData);
		    if (fileWriteData!=NULL)
                    	fclose(fileWriteData);

                    remove (datadirectory);
                    rename (datadirectoryTEMP, datadirectory);

                    sendall(sock, value_temp, strlen(value_temp));
                    sendall(sock, "\n", 1);
                }
                else
                {
                    // value string does not match the setup of the table
                    strcpy(update_value_temp, "ERR_INVALID_PARAM");
                    sendall(sock, update_value_temp, strlen(update_value_temp));
                    sendall(sock, "\n", 1);
                    return -1;
                }

            }
        }
        else
        {
            strcpy(value_temp, "ERR_NOT_AUTHENTICATED");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
            return -1;
        }
    }
    else if (is_query)
    {
        if (*auth_var)
        {
            // Client is authorized to access server
            printf("HERE\n");
            // Get the table name from the command
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, table_temp, 1, ";\0");

            table_index = has_table(params, table_temp);
            if (table_index == -1)
            {
                // table name DNE in the config params
                strcpy(value_temp, "ERR_TABLE_NOT_FOUND");
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
                return -1;
            }
            // Table does exist in the config_params
            printf("HERe\n");
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, pred_temp, 2, ";\0");
            printf("predicates: %s\n", pred_temp);
            int num_of_predicates = parse_predicates(pred_temp, table_index, params);
            if (num_of_predicates != -1)
            {
                printf("HErE\n");
                printf("Passed predicate parsing\n");
                return query_command(sock, pred_temp, tables, first_empty[table_index], table_index, params.numcolumnspertable[table_index], params.mycolumns, params.column_types);
            }
            else
            {
                printf("Gets here\n");
                strcpy(pred_temp, "ERR_INVALID_PARAM");
                sendall(sock, pred_temp, strlen(pred_temp));
                sendall(sock, "\n", 1);
                return -1;
            }
        }
        else
        {
            strcpy(value_temp, "ERR_NOT_AUTHENTICATED");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
            return -1;
        }
    }
    else if (is_delete)
    {
        if (*auth_var)
        {
            // Client is authorized to access server

            // Get the table name from the command
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, table_temp, 1, ";\0");

            printf("table_temp: %s\n", table_temp);
            printf("cmd: %s\n", cmd);

            table_index = has_table(params, table_temp);
            if (table_index == -1)
            {
                // Table does not exist in the config_params
                strcpy(value_temp, "ERR_TABLE_NOT_FOUND");
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
                printf("HERe\n");
                return -1;
            }
            // Table does exist in the config_params

            // Get the key of the value to delete
            strcpy(strtok_temp, cmd);
            get_param(strtok_temp, key_temp, 2, ";\0");
            printf("HERE\n");
            if (storage_PERM == 0)
            {
                // Use memory for storing the server
                strcpy(value_temp, delete_command(key_temp, tables, first_empty[table_index], table_index, params.numcolumnspertable[table_index], params.mycolumns));
                first_empty[table_index] = first_empty[table_index] - 1;
                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
            }
            else
            {

                FILE *fileLoadData;
                FILE *fileWriteData;

                char tablenamestring[MAX_TABLE_LEN + 100];
                char datadirectory[MAX_TABLE_LEN + 100];

                char tablenamestringTEMP[MAX_TABLE_LEN + 104];
                char datadirectoryTEMP[MAX_TABLE_LEN + 104];

                strcpy(datadirectory, "data/"); // from config file !!! REPLACE W/ PARSING
                strcpy(tablenamestring, table_temp);
                strcpy (tablenamestringTEMP, tablenamestring);
                strcat(tablenamestring, "_tbl.txt");
                strcat(tablenamestringTEMP, "_tbl_TEMP.txt");
                strcat(datadirectory, tablenamestring);
                strcat(datadirectoryTEMP, tablenamestringTEMP);
                fileLoadData = fopen (datadirectory, "rt");
                fileWriteData = fopen (datadirectoryTEMP, "w");
                strcpy(value_temp, delete_command_perm(key_temp, fileLoadData, fileWriteData));
                fclose(fileLoadData);
                fclose(fileWriteData);

                remove (datadirectory);
                rename (datadirectoryTEMP, datadirectory);

                sendall(sock, value_temp, strlen(value_temp));
                sendall(sock, "\n", 1);
            }
        }
        else
        {
            strcpy(value_temp, "ERR_NOT_AUTHENTICATED");
            sendall(sock, value_temp, strlen(value_temp));
            sendall(sock, "\n", 1);
            return -1;
        }
    }
    else
    {
        strcpy(value_temp, "ERR_UNKNOWN");
        sendall(sock, value_temp, strlen(value_temp));
        return -1;
    }
    return 0;
}


/**
 * @brief Start the storage server.
 *
 * This is the main entry point for the storage server.  It reads the
 * configuration file, starts listening on a port, and proccesses
 * commands from clients.
 */
int main(int argc, char *argv[])
{
    static char tables [MAX_TABLES][MAX_COLUMNS_PER_TABLE][MAX_RECORDS_PER_TABLE][MAX_STRTYPE_SIZE];
    int first_empty[MAX_TABLES], is_auth = 0, i;
    struct config_params params;

    // Initialize the number of elements in each table to 0
    for (i = 0; i < MAX_TABLES; i++)
    {
        first_empty[i] = 0;
    }

    time_t rawtime;
    struct tm *timeinfo;
    char timeStamp [50];

    time (&rawtime);
    timeinfo = localtime (&rawtime);

    strftime (timeStamp, 50, "Server-%F-%H-%M-%S.log", timeinfo);
    if (LOGGING_SERVER == 2)
    {
        fserverOut = fopen (timeStamp, "w+");
    }
    // Process command line arguments.
    // This program expects exactly one argument: the config file name.
    assert(argc > 0);
    if (argc != 2)
    {
        printf("Usage %s <config_file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    char *config_file = argv[1];

    // Read the config file.

    int status = read_config(config_file, &params);
    if (status != 0)
    {
        printf("Error processing config file.\n");
        exit(EXIT_FAILURE);
    }

    char log_message_serveron[150];
    sprintf(log_message_serveron, "Server on %s:%d\n", params.server_host, params.server_port);
    logger(fserverOut, log_message_serveron, LOGGING_SERVER);

    // Create a socket.
    int listensock = socket(PF_INET, SOCK_STREAM, 0);
    if (listensock < 0)
    {
        printf("Error creating socket.\n");
        exit(EXIT_FAILURE);
    }

    // Allow listening port to be reused if defunct.
    int yes = 1;
    status = setsockopt(listensock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes);
    if (status != 0)
    {
        printf("Error configuring socket.\n");
        exit(EXIT_FAILURE);
    }

    // Bind it to the listening port.
    struct sockaddr_in listenaddr;
    memset(&listenaddr, 0, sizeof listenaddr);
    listenaddr.sin_family = AF_INET;
    listenaddr.sin_port = htons(params.server_port);
    inet_pton(AF_INET, params.server_host, &(listenaddr.sin_addr)); // bind to local IP address
    status = bind(listensock, (struct sockaddr *) &listenaddr, sizeof listenaddr);
    if (status != 0)
    {
        printf("Error binding socket.\n");
        exit(EXIT_FAILURE);
    }

    // Listen for connections.
    status = listen(listensock, MAX_LISTENQUEUELEN);
    if (status != 0)
    {
        printf("Error listening on socket.\n");
        exit(EXIT_FAILURE);
    }

    // Listen loop.
    int wait_for_connections = 1;
    while (wait_for_connections)
    {
        // Wait for a connection.
        struct sockaddr_in clientaddr;
        socklen_t clientaddrlen = sizeof clientaddr;
        int clientsock = accept(listensock, (struct sockaddr *)&clientaddr, &clientaddrlen);
        if (clientsock < 0)
        {
            printf("Error accepting a connection.\n");
            exit(EXIT_FAILURE);
        }

        char log_message_getconnection[150];
        sprintf(log_message_getconnection, "Got a connection from %s:%d.\n", inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port);
        logger(fserverOut, log_message_getconnection, LOGGING_SERVER);

        // Get commands from client.edit
        int wait_for_commands = 1;
        do
        {
            // Read a line from the client.
            char cmd[MAX_CMD_LEN];
            int status = recvline(clientsock, cmd, MAX_CMD_LEN);
            if (status != 0)
            {
                // Either an error occurred or the client closed the connection.
                wait_for_commands = 0;
            }
            else
            {
                // Handle the command from the client.
                int status = handle_command(clientsock, params, cmd, tables, first_empty, &is_auth);
                if (status !=    0)
                    wait_for_commands = 0; // Oops.  An error occured.
            }
        }
        while (wait_for_commands);

        // Close the connection with the client.
        close(clientsock);
        is_auth = 0;

        char log_message_closeconnection[150];
        sprintf(log_message_closeconnection, "Closed connection from %s:%d.\n", inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port);
        logger(fserverOut, log_message_closeconnection, LOGGING_SERVER);
    }

    // Stop listening for connections.
    close(listensock);

    return EXIT_SUCCESS;
}

